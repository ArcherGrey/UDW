# 309. 最佳买卖股票时机含冷冻期

## 题目

给定一个整数数组，其中第 `i` 个元素代表了第 `i` 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

```
示例:

输入: [1,2,3,0,2]
输出: 3
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

## 题解

### 动态规划

`f[i]` 表示第 `i` 天结束之后的累计最大收益，所以会有三种状态

- 持有股票 `f[i][0]`
- 不持有股票且处于冻结期 `f[i][1]`
- 不持有且不处于冻结期 `f[i][2]`

对应的状态转移方程：

- 对于 `f[i][0]`，那么有两种可能
  - `i-1` 已经持有 对应状态 `f[i-1][0]`
  - `i` 天才买入，`i-1` 就不能持有股票且不处于冷冻期，对应状态 `f[i-1][2]`，再减去买入股票的成本 `prices[i]`

> `f[i][0] = max(f[i-1][0], f[i-1][2]-prices[i])`

- 对于 `f[i][1]`，说明 `i-1` 天必须持有股票，再加上卖出股票的收益 `prices[i]`

> `f[i][1] = f[i-1][0] + prices[i]`

- 对于 `f[i][2]`，说明 `i-1` 天没有做任何操作，可能是处于冷冻期或者不处于冷冻期

> `f[i][2] = max(f[i-1][1], f[i-1][2])`

如果有 `n` 天，最终的答案就是

> `max(f[n-1][0], f[n-1][1], f[n-1][2])`

实际上如果最后一天还持有股票，显然不是最优解，所以答案应该为：

> `max(f[n-1][1], f[n-1][2])`

第 0 天作为边界条件：

- `f[0][0] = -prices[0]`
- `f[0][1] = 0`
- `f[0][2] = 0`

```JavaScript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
  const n = prices.length;
  if (n < 2) return 0;
  let dp = new Array(n);
  for (let i = 0; i < n; ++i) {
    dp[i] = new Array(3).fill(0);
  }
  dp[0][0] = -prices[0];
  dp[0][1] = dp[0][2] = 0;
  let i = 1;
  while (i < n) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
    dp[i][1] = dp[i - 1][0] + prices[i];
    dp[i][2] = Math.max(dp[i - 1][1], dp[i - 1][2]);
    i++;
  }
  return Math.max(dp[i - 1][1], dp[i - 1][2]);
};

```
