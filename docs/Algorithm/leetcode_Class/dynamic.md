# 动态规划

[toc]

:::info
动态规划（Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
:::

动态规划不是某一种具体的算法，而是一种算法思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

应用这种算法思想解决问题的可行性，对子问题与原问题的关系，以及子问题之间的关系这两方面有一些要求，它们分别对应了最优子结构和重复子问题。

## 最优子结构

> 最优子结构规定的是子问题与原问题的关系

动态规划要解决的都是一些问题的最优解，即从很多解决问题的方案中找到最优的一个。当我们在求一个问题最优解的时候，如果可以把这个问题分解成多个子问题，然后递归地找到每个子问题的最优解，最后通过一定的数学方法对各个子问题的最优解进行组合得出最终的结果。总结来说就是一个问题的最优解是由它的各个子问题的最优解决定的。

将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。在解题中一般用状态转移方程描述这种组合。

找到了最优子结构，也就能推导出一个状态转移方程，通过这个状态转移方程，我们能很快的写出问题的递归实现方法。

## 重复子问题

> 重复子问题规定的是子问题与子问题的关系。

当我们在递归地寻找每个子问题的最优解的时候，有可能会会重复地遇到一些更小的子问题，而且这些子问题会重叠地出现在子问题里，出现这样的情况，会有很多重复的计算，动态规划可以保证每个重叠的子问题只会被求解一次。当重复的问题很多的时候，动态规划可以减少很多重复的计算。

重复子问题不是保证解的正确性必须的，但是如果递归求解子问题时，没有出现重复子问题，则没有必要用动态规划，直接普通的递归就可以了。

> 解决动态规划问题的核心：找出子问题及其子问题与原问题的关系

找到了子问题以及子问题与原问题的关系，就可以递归地求解子问题了。但重叠的子问题使得直接递归会有很多重复计算，于是就想到记忆化递归法：若能事先确定子问题的范围就可以建表存储子问题的答案。

动态规划算法中关于最优子结构和重复子问题的理解的关键点：

1. 证明问题的方案中包含一种选择，选择之后留下一个或多个子问题
2. 设计子问题的递归描述方式
3. 证明对原问题的最优解包括了对所有子问题的最优解
4. 证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）

难点:

- 定义状态
- 得到状态转移方程

## 和分治,贪心比较

|            |    分治    |  动态规划  |   贪心   |
| :--------: | :--------: | :--------: | :------: |
|  适用类型  |    通用    |    优化    |   优化   |
|   子问题   | 每个都不同 |  存在重复  | 只有一个 |
| 最优子结构 |  没有要求  |  必须满足  | 必须满足 |
|  子问题数  | 全部都要解 | 全部都要解 | 只解一个 |

## 线性动态规划

:::info
主要特点是状态的推导是按照问题规模从小到大依次推过去,较大规模问题依赖较小规模问题的解
:::

规模为 `i` 的含义是前 `i` 个元素的解

状态定义: `dp[n] = [0,...n]` 的解

状态转移: `dp[n] = f(dp[n-1],....,dp[0])`

解决的主要问题:

- 单串
- 双串
- 矩阵

### 单串

线性动态规划中最简单的一类,输入是一个串

状态转移 `dp[i] = f(dp[i-1],....,dp[0])`

1. `dp[n]` 只和常数个小规模子问题相关
2. `dp[n]` 和更小规模的所有子问题相关

练习

- 经典 `LIS` 系列
  - 300
  - 673
  - 354
- 最大子数组和系列
  - 53
  - 152
  - 918 kadane 算法
- 打家劫舍系列
  - 198
  - 213
  - 740
