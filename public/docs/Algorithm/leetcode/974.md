# 974. 和可被 K 整除的子数组

## 题目

给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

示例：

```auto
输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

提示：

```auto
1 <= A.length <= 30000
-10000 <= A[i] <= 10000
2 <= K <= 10000
```

## 题解

### 哈希表 + 逐一统计

涉及连续子数组问题，通常使用前缀和解决

令 `P[i] = A[0] = A[1] + ... + A[i]`

那么每个连续子数组的和 `sum(i,j)` 就可以写成 `p[j] - p[i-1]`

判断子数组能否被 `k` 整除就等价于 判断 `(p[j] - p[i-1]) mod K == 0`

由同余定理得到只要 `P[j] mod K == P[i-1] mod K` 就可以保证上面成立

可以维护一个前缀和为模 k 的值为键，出现次数为值的哈希表 `record`，在遍历的同时进行更新

```JavaScript
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var subarraysDivByK = function (A, K) {
  // 这里代表哈希表
  let record = [];
  for (let j = 0; j < K; ++j) {
    record[j] = 0;
  }
  record[0] = 1;
  let sum = 0,
    ans = 0;
  for (let i = 0; i < A.length; ++i) {
    sum += A[i];
    // 兼容负数情况
    let mod = ((sum % K) + K) % K;
    // 这里简写
    // 因为如果存在 mod 值相同的每个前缀和都能和当前的组成 mod 为0 的子数组
    // 所以直接加上前缀和相同的个数
    // if(record[mod]>0){
    //   ans+=record[mod]
    // }
    ans += record[mod];
    record[mod] = record[mod] + 1;
  }
  return ans;
};

```

时间复杂度：O(N)，其中 N 是数组 A 的长度。我们只需要从前往后遍历一次数组，在遍历数组的过程中，维护哈希表的各个操作均为 O(1)，因此总时间复杂度为 O(N)。

空间复杂度：O(min(N,K))，即哈希表需要的空间。当 `N≤K` 时，最多有 N 个前缀和，因此哈希表中最多有 N+1 个键值对；当 N > K 时，最多有 K 个不同的余数，因此哈希表中最多有 K 个键值对。也就是说，哈希表需要的空间取决于 N 和 K 中的较小值。

### 哈希表 + 单次统计

还是统计前缀和，相同前缀和的子数组通过排列组合的方式依次计算出每个 mod 值的结果，再相加

```JavaScript

```

时间复杂度：O(N)，其中 N 是数组 A 的长度。我们首先从前往后遍历一次数组，时间复杂度为 O(N)。随后我们遍历哈希表并求出答案，由于哈希表中最多只有 min(N+1,K) 个键值对，因此遍历的时间复杂度不会超过 O(N)，总时间复杂度为 O(N)。

空间复杂度：O(min(N,K))，即哈希表需要的空间。
