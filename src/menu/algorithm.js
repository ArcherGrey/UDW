/* 算法 */
import { buildItemByType, buildSubmenu } from "./common.js";

const parent = {
  id: "10",
  path: "./docs/Algorithm/"
};
const bs = buildSubmenu(parent);

// leetcode 题解
const p1 = bs(1, "leetcode");
const buildItem1 = buildItemByType(p1, "leetcode");
const leetcode = {
  id: p1.id,
  label: "leetcode题解",
  children: buildItem1([
    [1, "两数之和"],
    [3, "无重复字符的最长子串"],
    [5, "最长回文子串"],
    [7, "整数反转"],
    [9, "回文数"],
    [13, "罗马数字转整数"],
    [14, "最长公共前缀"],
    [15, "三数之和"],
    [16, "最接近的三数之和"],
    [17, "电话号码的字母组合"],
    [20, "有效的括号"],
    [21, "合并两个有序链表"],
    [24, "两两交换链表中的节点"],
    [26, "删除排序数组中的重复项"],
    [27, "移除元素"],
    [28, "实现 strStr()"],
    [31, "下一个排列"],
    [33, "搜索旋转排序数组"],
    [34, "在排序数组中查找元素的第一个和最后一个位置"],
    [35, "搜索插入位置"],
    [36, "有效的数独"],
    [37, "解数独"],
    [39, "组合总和"],
    [40, "组合总和 II"],
    [41, "缺失的第一个正数"],
    [43, "字符串相乘"],
    [44, "通配符匹配"],
    [47, "全排列 II"],
    [49, "字母异位词分组"],
    [50, "Pow(x,n)"],
    [53, "最大子序和"],
    [57, "插入区间"],
    [62, "不同路径"],
    [64, "最小路径和"],
    [66, "加一"],
    [67, "二进制求和"],
    [69, "x 的平方根"],
    [70, "爬楼梯"],
    [76, "最小覆盖子串"],
    [77, "组合"],
    [84, "柱状图中最大的矩形"],
    [88, "合并两个有序数组"],
    [94, "二叉树中序遍历"],
    [95, "不同的二叉搜索树 II"],
    [96, "不同的二叉搜索树"],
    [100, "相同的树"],
    [101, "对称二叉树"],
    [102, "二叉树的层序遍历"],
    [104, "二叉树的最大深度"],
    [105, "从前序与中序遍历序列构造二叉树"],
    [106, "从中序与后序遍历序列构造二叉树"],
    [107, "二叉树的层次遍历 II"],
    [108, "将有序数组转换为二叉搜索树"],
    [109, "有序链表转换二叉搜索树"],
    [110, "平衡二叉树"],
    [111, "二叉树的最小深度"],
    [112, "路径总和"],
    [114, "二叉树展开为链表"],
    [116, "填充每个节点的下一个右侧节点指针"],
    [117, "填充每个节点的下一个右侧节点指针 II"],
    [118, "杨辉三角"],
    [119, "杨辉三角 II"],
    [120, "三角形最小路径和"],
    [121, "买卖股票的最佳时机"],
    [122, "买卖股票的最佳时机 II"],
    [125, "验证回文串"],
    [127, "单词接龙"],
    [129, "求根到叶子节点数字之和"],
    [130, "被围绕的区域"],
    [133, "克隆图"],
    [135, "分发糖果"],
    [136, "只出现一次的数字"],
    [141, "环形链表"],
    [144, "二叉树的前序遍历"],
    [145, "二叉树的后序遍历"],
    [146, "LRU 缓存机制"],
    [147, "对链表进行插入排序"],
    [150, "逆波兰表达式求值"],
    [152, "乘积最大子数组"],
    [155, "最小栈"],
    [159, "至多包含两个不同字符的最长子串"],
    [164, "最大间距"],
    [167, "两数之和 II - 输入有序数组"],
    [169, "多数元素"],
    [170, "两数之和 III - 数据结构设计"],
    [189, "旋转数组"],
    [198, "打家劫舍"],
    [200, "岛屿数量"],
    [202, "快乐数"],
    [205, "同构字符串"],
    [206, "反转链表"],
    [207, "课程表"],
    [209, "长度最小的子数组"],
    [213, "打家劫舍 II"],
    [215, "数组中的第 K 个最大元素"],
    [216, "组合总和 III"],
    [217, "存在重复元素"],
    [219, "存在重复元素 II"],
    [221, "最大正方形"],
    [226, "翻转二叉树"],
    [234, "回文链表"],
    [235, "二叉搜索树的最近公共祖先"],
    [236, "二叉树的最近公共祖先"],
    [238, "除自身以外数组的乘积"],
    [243, "最短单词距离"],
    [249, "移位字符串分组"],
    [256, "粉刷房子"],
    [257, "二叉树的所有路径"],
    [268, "缺失数字"],
    [270, "最接近的二叉搜索树值"],
    [276, "栅栏涂色"],
    [279, "完全平方数"],
    [283, "移动零"],
    [287, "寻找重复数"],
    [288, "单词的唯一缩写"],
    [290, "单词规律"],
    [297, "二叉树的序列化与反序列化"],
    [300, "最长上升子序列"],
    [303, "区域和检索 - 数组不可变"],
    [309, "最佳买卖股票时机含冷冻期"],
    [311, "稀疏矩阵的乘法"],
    [328, "奇偶链表"],
    [332, "重新安排行程"],
    [336, "回文对"],
    [337, "打家劫舍 III"],
    [343, "整数拆分"],
    [347, "前 K 个高频元素"],
    [349, "两个数组的交集"],
    [350, "两个数组的交集 II"],
    [354, "俄罗斯套娃信封问题"],
    [368, "最大整除子集"],
    [378, "有序矩阵中第K小的元素"],
    [380, "常数时间插入、删除和获取随机元素"],
    [387, "字符串中的第一个唯一字符"],
    [389, "找不同"],
    [392, "判断子序列"],
    [394, "字符串解码"],
    [401, "二进制手表"],
    [404, "左叶子之和"],
    [406, "根据身高重建队列"],
    [413, "等差数列划分"],
    [414, "第三大的数"],
    [415, "字符串相加"],
    [424, "替换后的最长重复字符"],
    [437, "路径总和 III"],
    [448, "找到所有数组中消失的数字"],
    [452, "用最少数量的箭引爆气球"],
    [454, "四数相加 II"],
    [459, "重复的子字符串"],
    [463, "岛屿的周长"],
    [471, "编码最短长度的字符串"],
    [485, "最大连续1的个数"],
    [486, "预测赢家"],
    [491, "递增子序列"],
    [494, "目标和"],
    [501, "二叉搜索树中的众数"],
    [509, "斐波那契数"],
    [514, "自由之路"],
    [529, "扫雷游戏"],
    [530, "二叉搜索树的最小绝对差"],
    [532, "数组中的 K-diff 数对"],
    [538, "把二叉搜索树转换为累加树"],
    [542, "01 矩阵"],
    [560, "和为k的子数组"],
    [561, "数组拆分 I"],
    [566, "重塑矩阵"],
    [572, "另一个树的子树"],
    [581, "最短无序连续子数组"],
    [599, "两个列表的最小索引总和"],
    [605, "种花问题"],
    [617, "合并二叉树"],
    [624, "数组列表中的最大距离"],
    [628, "三个数的最大乘积"],
    [637, "二叉树的层平均值"],
    [647, "回文子串"],
    [649, "Dota2 参议院"],
    [652, "寻找重复的子树"],
    [657, "机器人能否返回原点"],
    [659, "分割数组为连续子序列"],
    [673, "最长递增子序列的个数"],
    [680, "验证回文字符串 Ⅱ"],
    [687, "最长同值路径"],
    [696, "计数二进制子串"],
    [701, "二叉搜索树中的插入操作"],
    [705, "设计哈希集合"],
    [706, "设计哈希映射"],
    [718, "最长重复子数组"],
    [725, "打开转盘锁"],
    [733, "图像渲染"],
    [738, "单调递增的数字"],
    [739, "每日温度"],
    [740, "删除与获得点数"],
    [746, "使用最小花费爬楼梯"],
    [767, "重构字符串"],
    [771, "宝石与石头"],
    [779, "第K个语法符号"],
    [783, "二叉搜索树节点最小距离"],
    [785, "判断二分图"],
    [821, "新21点"],
    [841, "钥匙和房间"],
    [842, "将数组拆分成斐波那契序列"],
    [844, "比较含退格的字符串"],
    [860, "柠檬水找零"],
    [861, "翻转矩阵后的得分"],
    [873, "最长的斐波那契子序列的长度"],
    [918, "环形子数组的最大和"],
    [922, "按奇偶排序数组 II"],
    [925, "长按键入"],
    [941, "有效的山脉数组"],
    [973, "最接近原点的 K 个点"],
    [974, "和可被 K 整除的子数组"],
    [977, "有序数组的平方"],
    [983, "最低票价"],
    [990, "等式方程的可满足性"],
    [1002, "查找常用字符"],
    [1004, "最大连续1的个数 III"],
    [1014, "最佳观光组合"],
    [1025, "除数博弈"],
    [1027, "最长等差数列"],
    [1028, "从先序遍历还原二叉树"],
    [1030, "距离顺序排列矩阵单元格"],
    [1047, "删除字符串中的所有相邻重复项"],
    [1055, "形成字符串的最短路径"],
    [1095, "山脉数组中查找目标值"],
    [1207, "独一无二的出现次数"],
    [1356, "根据数字二进制下 1 的数目排序"],
    [1365, "有多少小于当前数字的数字"],
    [1370, "上升下降字符串"],
    [1371, "每个元音包含偶数次的最长子字符串"],
    [1388, "3n 块披萨"],
    [1431, "拥有最多糖果的孩子"],
    ["i29", "顺时针打印矩阵"],
    ["i46", "把数字翻译成字符串"],
    ["i51", "数组中的逆序对"],
    ["i56", "I. 数组中数字出现的次数"],
    ["i64", "求 1+2+…+n"]
  ])
};
// leetcode 探索
const p2 = bs(2, "leetcode_Class");
const buildItem2 = buildItemByType(p2);
const book = {
  id: p2.id,
  label: "leetcode 探索",
  children: buildItem2([
    ["队列&栈", "queue_stack"],
    ["哈希表", "hash"],
    ["递归", "recursion"],
    ["动态规划", "dynamic"]
  ])
};

// 图
const p3 = bs(3, "graph");
const buildItem3 = buildItemByType(p3);
const graph = {
  id: p3.id,
  label: "图",
  children: buildItem3([["欧拉图", "euler"]])
};

// 排序
const p4 = bs(4, "sort");
const buildItem4 = buildItemByType(p4);
const sort = {
  id: p4.id,
  label: "排序查找",
  children: buildItem4([
    ["二分查找", "bs"],
    ["快速排序", "quick"],
    ["基数排序", "radix"]
  ])
};

// 字符串
const p5 = bs(5, "string");
const buildItem5 = buildItemByType(p5);
const string = {
  id: p5.id,
  label: "字符串",
  children: buildItem5([["kmp", "kmp"]])
};

// 树
const p6 = bs(6, "tree");
const buildItem6 = buildItemByType(p6);
const tree = {
  id: p6.id,
  label: "树",
  children: buildItem6([
    ["二叉树遍历", "btTravers"],
    ["二叉树常见问题", "btQs"],
    ["回溯", "backtrack"]
  ])
};

export const algorithmIndex = [leetcode, book, graph, sort, string, tree];
